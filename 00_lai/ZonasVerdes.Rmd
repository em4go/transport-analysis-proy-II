---
title: "Obtención Zonas Verdes"
author: "Laiqian Ji"
date: "2024-04-02"
output: 
  html_document:
    toc: true
    number_sections: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
En este RMarkdown se explica cómo se han obtenido los datos de zonas verdes de cada barrio.

# Carga de librerías

Antes de comenzar, vamos a cargar las librerías que necesitaremos para las transformaciones, etc.

```{r libraries}
library(tidyverse)
library(ggplot2)
library(leaflet)
library(jsonlite)
library(sf)
library(geojsonsf)
library(geojsonio)
library(purrr)
library(osmdata)
```

# Script

Ahora, cargaremos los datos que hemos obtenido de la página web "https://valencia.opendatasoft.com/explore/embed/dataset/zonas-verdes/table/?flg=es-es&disjunctive.nivel3".

```{r Carga}
file <- "zonas-verdes.csv"
df <- read.csv2(file=file)
df$m2_poligon <- round(as.numeric(df$m2_poligon), 0)

# Quito las columnas que contienen "m2zv" ya que no son de interés
df <- df[ , !grepl("m2zv", names(df))]

head(df)
```

# Obtener suma de m2 por barrio

Para ello, utilizaremos el geo_shape de cada zona verde y sumaremos el area de esa figura geométrica.

```{r string_vacio}
# Comprobamos si hay algún string vacío en la columna 'geo_shape'
hay_string_vacio <- any(grepl("^$", df$geo_shape))
print(hay_string_vacio)

df <- subset(df, !grepl("^$", geo_shape))

# Comprobamos si sigue habiendo algún string vacío en la columna 'geo_shape'
hay_string_vacio <- any(grepl("^$", df$geo_shape))
print(hay_string_vacio)
```

Ahora, vamos a obtener la suma de las áreas de cada polígono.

```{r suma_m2}
# Convertimos la columna 'geo_shape' a tipo 'sf'
df$geo_shape <- map(df$geo_shape, geojson_sf)

# Calculamos el área de cada polígono
lista_area <- map(df$geo_shape, st_area)
df$area <- unlist(lista_area)
df$area <- round(df$area, 0)

# Redondeo a la decena por abajo
df$area <- floor(df$area / 10) * 10
```

# Clasificación por barrios

Como al final queremos estudiar los barrios y no las zonas individuales, vamos a reorganizar el dataframe para que esté por barrios.

```{r poligonos} 
# Ahora, vamos a meter cada polígono en un barrio mediante su geo_point
obtener_poligonos <- function(df){
  polygons <- lapply(barrios$geo_shape, function(x) st_read(x, quiet = TRUE))
  
  # Combina todos los objetos sf en un solo objeto sf
  polygons_barrios <- do.call(rbind, polygons)
  
  polygons_barrios$Nombre <- barrios$Nombre
  return(polygons_barrios)
}

# Cargamos los datos de los barrios
barrios <- read.csv2("../data/barrios_valencia.csv", sep = ";")
polygons_barrios <- obtener_poligonos(barrios)
head(polygons_barrios, 5)
```

Mediante la columna geo_point_2d, vamos a asignar cada polígono a un barrio

```{r puntos}
# Separo geo_point_2d en dos columnas: x e y.
# Debo hacer un split 
cords <- strsplit(df$geo_point_2d, ",")
df$x <- sapply(cords, function(x) x[1])
df$y <- sapply(cords, function(x) x[2])
df$x <- as.numeric(df$x)
df$y <- as.numeric(df$y)

for (zv in 1:nrow(df)) {
  y <- df$x[zv]
  x <- df$y[zv]
  point <- st_point(c(x, y))
  # b devuelve una lista con el índice del polígono en el que está el nodo
  b <- unlist(st_within(point, polygons_barrios$geometry)) 

  # Si el nodo está en un polígono, asigno el nombre del barrio correspondiente
  if (length(b) > 0) {
    df$barrio[zv] <- polygons_barrios$Nombre[b]
  } else {
    df$barrio[zv] <- 'Otro'
  }
}

# Obtengo un data frame resumen con la suma de las áreas de las zonas verdes por barrio
df_resumen <- df %>% group_by(barrio) %>% summarise(area = sum(area))

head(df_resumen)
```

