---
title: "Tabla para caracterizar los barrios de Valencia"
author: "Ferran Aragó"
output: 
  html_document:
    toc: true
    number_sections: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: true
knit_root_dir: ..
---
```{r setup, include=FALSE, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(leaflet)
library(igraph)
library(osmdata)
library(sf)
library(ggplot2)
library(jsonlite)
library(dplyr)
library(arrow)
library(geojsonsf)
library(tidyr)
library(arrow)
library(tidytransit)
library(stringi)
```

# Creación de la base de datos de los barrios de Valencia

Para la creación del dataset que caracteriza cada uno de los barrios de Valencia se han utilizado diferente fuentes y formatos de datos de forma que, de cada uno de ellos, se obtenían los datos necesarios para incluirlos en el dataset.

Cada uno de estos datos se debe comprobar a que barrio pertenecía para así realizar el conteo para cada uno de los barrios y caracterizarlos. Esta función se ha realizado de dos formas: 

1. Es la más sencilla y consiste en concatenar directamente ambos datasets con la información deseada ya que en ambos se dispone de la información asociada a cada uno de los barrios. Se realiza mediante la función `merge` de R.

2. Esta otra resulta más complicada y se daba cuando no se dispone de la información relativa a cada barrio sino del objeto de análisis y su localización. En este caso se verifica a que barrio pertenece comprobando dentro de que polígono de cada barrio se encuentra el objeto.

Para realizar esto se han generado distintos scripts ya que se han subdividido las tareas de obtención de los datos y, posteriormente, se unen cada uno de los resultados de cada script en un dataset que genera el script descrito en este documento. En todos los casos se ha utilizado las dos técnicas comentadas anteriormente.

# Script para el dataset final

## Funciones

Aquí se establecen las funciones que se han utilizado para mejorar la eficiencia del código.


```{r funciones}
establecer_localizacion <- function(punto, info_poligonos) {
  # Vamos a crear una función para que devuelva directamente el polígono al que
  # pertenece un punto
  b <- unlist(st_within(punto, info_poligonos$geometry))
  if (length(b) == 0) {
    return(NA)
  } else {
    return(info_poligonos$barrio[b])
  }
}

obtener_poligonos <- function(df){
  polygons <- lapply(distritos$geo_shape, function(x) st_read(x, quiet = TRUE))
  
  # Combina todos los objetos sf en un solo objeto sf
  poligonos <- do.call(rbind, polygons)
  
  poligonos$Nombre <- distritos$Nombre
  return(poligonos)
}
```

## Adición de la población

Podemos ver que se toma como base el fichero de tipo parquet `valenbisi_barrio`. En este fichero ya se recogen el número de estaciones de valenbisi para cada barrio, al igual que el número de metros de carril bici del que dispone, el polígono que representa cada barrio, por si es necesario para obtener el barrio al que pertenece un objeto y para conocer la superficie del barrio.

Los datos a cerca de la localización de las estaciones de valenbisi se han obtenido de la pagina web de datos abiertos de Valencia. En cambio, los metros de carril bici se han calculado mediante el uso del grafo obtenido de openstreetmap, mediante la librería `osmdata`.

Posteriormente se procede a añadirle la población de cada barrio. En este caso, se utiliza la primera técnica comentada, ya que si se dispone de la información ya separada por barrios.


```{r población}
# Lectura del fichero con información del valenbisi por barrios de valencia
valenba_barrio <- read_parquet("../data/valenbisi_barrio.parquet")

# Fichero con los datos de población por barrio
poblacion <- read.csv2("../00_hervas/Barrios_Pob.csv", sep = ";", header = TRUE, encoding = "UTF-8")

# Eliminación de los distritos
poblacion <- poblacion %>% filter(!grepl("^$",Total))

# Eliminación de la primera fila
poblacion <- poblacion %>% filter(!grepl("^$",X))

# Eliminación de la primera fila con el valor de total, para quedarnos con los barrios
poblacion <- poblacion[2:nrow(poblacion),]

# Cambio de nombre de la columna para poder realizar el merge
poblacion$barrio <- toupper(sapply(strsplit(stri_trans_general(poblacion$X,"Latin-ASCII"), "\\. "), function(x) x[2]))

poblacion <- poblacion %>% select(-c(X, X.1, X.2, X.3, X.4, X.5, X.6, X.7, X.8))

colnames(poblacion) <- c("Total_poblacion", "0-15 años", "16-64 años", "65 o más", "barrio")

poblacion$Total_poblacion <- as.numeric(poblacion$Total_poblacion)
poblacion$`0-15 años` <- as.numeric(poblacion$`0-15 años`)
poblacion$`16-64 años` <- as.numeric(poblacion$`16-64 años`)
poblacion$`65 o más` <- as.numeric(poblacion$`65 o más`)

valenba_barrio <- merge(valenba_barrio, poblacion, by = "barrio", all.x = TRUE)
```

## Adición de la superficie del barrio

Esto se realiza de forma rápida. Transformamos el geoJson en un objeto de tipo `sf` y calculamos la superficie de cada barrio.

```{r superficie}
valenba_barrio$geometry <- geojson_sf(valenba_barrio$geo_shape)

# datos sobre la superficie de los barrios
valenba_barrio$superficie_barrio <- st_area(valenba_barrio$geometry)
```

## Adición de los datos del transporte público

En este apartado se muestra como se han añadido el número de paradas de bus, metro y tranvía que posee cada barrio. En este caso los datos se han obtenido de los distintos ficheros GTFS que se han descargado de la página web de MobilityData. En estos GTFS se encuentran los datos de localización de cada una de las paradas entre otros. Con cada una da estas paradas se comprueba a que barrio pertenece y se cuenta cuantas paradas tiene cada barrio.


```{r transporte_publico}
# datos sobre transporte público
emt <- read_gtfs("../data/gtfs_data/transit_emt_valencia.zip")

paradas <- emt$stops
paradas$stop_lat <- as.numeric(paradas$stop_lat)
paradas$stop_lon <- as.numeric(paradas$stop_lon)

#Creación de un objeto de tipo sf con las paradas
coordenadas <- subset(paradas, select = c("stop_lat", "stop_lon"))

b <- st_as_sf(coordenadas, coords = c("stop_lon", "stop_lat"), crs = 4326)
paradas <- cbind(paradas, b)

# Añadimos al data.frame de paradas la información de los barrios

paradas$barrio <- lapply(paradas$geometry, function(x) establecer_localizacion(x, valenba_barrio))


# Contamos cuantas paradas tiene cada barrio y lo añadimos al data.frame
emt_barrio <- paradas %>% group_by(barrio) %>% summarise(paradas_emt = n())

valenba_barrio <- merge(valenba_barrio, emt_barrio, by = "barrio", na.rm = TRUE, all.x = T)


# Datos sobre el metro y tranvía

metro <- read_gtfs("../data/gtfs_data/transit_metrovalencia.zip")

paradas_metro <- metro$stops

paradas_metro$stop_lat <- as.numeric(paradas_metro$stop_lat)
paradas_metro$stop_lon <- as.numeric(paradas_metro$stop_lon)

#Creación de un objeto de tipo sf con las paradas
coordenadas_metro <- subset(paradas_metro, select = c("stop_lat", "stop_lon"))

b <- st_as_sf(coordenadas_metro, coords = c("stop_lon", "stop_lat"), crs = 4326)
paradas_metro <- cbind(paradas_metro, b)

# Añadimos al data.frame de paradas la información de los barrios

paradas_metro$barrio <- lapply(paradas_metro$geometry, function(x) establecer_localizacion(x, valenba_barrio))


# Contamos cuantas paradas tiene cada barrio y lo añadimos al data.frame
metro_barrio <- paradas_metro %>% group_by(barrio) %>% summarise(paradas_metro = n())

valenba_barrio <- merge(valenba_barrio, metro_barrio, by = "barrio", all.x = TRUE, na.rm = TRUE)
```

## Adición de datos acerca dee plazas de aparcamiento, taxis y zonas verdes

Como se ha comentado al inicio del documento, se han dividido la obtención de datos, es por ello que para insertar los datos de este apartado simplemente se ha tenido que leer los ficheros y añadirlos al dataset mediante el uso de la primera técnica comentada, ya que los datos ya han sido tratados en sus respectivos scripts.


```{r parkings_zonas_verdes}  
# DATOS SOBRE LOS PARKINGS DE CADA BARRIO
parkings <- read_parquet("../00_marc/dataTratada/info_barrio.parquet")
# Eliminación de los acentos y paso a mayúsculas

prk2merge <- select(parkings, c("barrio",setdiff(colnames(parkings), colnames(valenba_barrio))))

valenba_barrio <- merge(valenba_barrio, prk2merge, by= "barrio", all.x = TRUE, na.rm = TRUE)


#DATOS SOBRE ZONAS VERDES

zonas_verdes <- read.csv("../data/zonas_verdes_por_barrio.csv", sep = ";")

colnames(zonas_verdes) <- c("barrio", "superficie_zonas_verdes")

valenba_barrio <- merge(valenba_barrio, zonas_verdes, by = "barrio", all.x = TRUE, na.rm = TRUE)
```




## Adición del coste de alquiler del metro cuadrado

Estos datos se obtienen de un fichero csv de la página web de datos abiertos de valencia, por ello, ya se dispone de la información separada por barrios. Por lo tanto, se utiliza la primera técnica comentada para añadir estos datos al dataset.

```{r alquiler}
alquiler <- read.csv("../data/precio-alquiler-vivienda.csv", sep = ";")

alq2merg <- select(alquiler, c("BARRIO", "Precio_2022..Euros.m2."))
colnames(alq2merg) <- c("barrio", "precio_alquiler")

valenba_barrio <- merge(valenba_barrio, alq2merg, by = "barrio", all.x = TRUE, na.rm = TRUE)
```

## Adición del distrito

También se le añade el distrito al que pertenece cada barrio para poder agruparlos por distrito si fuese necesario en los posteriores análisis.

Para ello se concatena sobre el `data.frame` el nombre del distrito al que pertenece cada barrio obtenido de ambos ficheros de información acerca de barrios y distritos de los datos abiertos, que pueden concatenarse por el código de distrito.

```{r distrito}
aux_barrios <- read.csv("../data/barrios_valencia.csv", sep = ";")
aux_barrios <- aux_barrios %>% select(c("Nombre", "Codigo.distrito"))
colnames(aux_barrios) <- c("barrio", "Codigo.distrito")

aux_distritos <- read.csv("../data/distritos_valencia.csv", sep = ";")
aux_distritos <- aux_distritos %>% select(c("Nombre", "Código.distrito"))
aux_distritos <- unique(aux_distritos)
colnames(aux_distritos) <- c("distrito", "Codigo.distrito")

barrio_distrito <- aux_barrios %>% left_join(aux_distritos, by = "Codigo.distrito")
barrio_distrito <- barrio_distrito %>% select(c("barrio", "distrito"))

valenba_barrio <- merge(valenba_barrio, barrio_distrito, by = "barrio", all.x = TRUE, na.rm = TRUE)
valenba_barrio$distrito <- as.factor(valenba_barrio$distrito)
```

## Adición de puntos de interés

```{r}
amenity <- read_parquet("../00_hervas/sitios_interes/amenity.parquet")

colnames(amenity) <- c("barrio", "amenity")

valenba_barrio <- merge(valenba_barrio, amenity, by= "barrio", all.x = TRUE, na.rm = TRUE)




monuments <- read_parquet("../00_hervas/sitios_interes/monuments.parquet")

colnames(monuments) <- c("barrio", "monuments")

valenba_barrio <- merge(valenba_barrio, monuments, by= "barrio", all.x = TRUE, na.rm = TRUE)




shop <- read_parquet("../00_hervas/sitios_interes/shop.parquet")

colnames(shop) <- c("barrio", "shop")

valenba_barrio <- merge(valenba_barrio, shop, by= "barrio", all.x = TRUE, na.rm = TRUE)




sport <- read_parquet("../00_hervas/sitios_interes/sport.parquet")

colnames(sport) <- c("barrio", "sport")

valenba_barrio <- merge(valenba_barrio, sport, by= "barrio", all.x = TRUE, na.rm = TRUE)
```






