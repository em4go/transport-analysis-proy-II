---
title: "Ratios de comparación"
author: "Ferran Aragó"
date: "r sys.Date() format('%d %B, %Y')"
output: 
  html_document:
    toc: true
    number_sections: false
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(geojsonsf)
library(sf)
library(arrow)
library(leaflet)
```


# Lectura de los datos

Vamos a utilizar tanto el dataframe en el que se han dividido los datos por la superficie como el que no, ya que así ya disponemos de la información de los datos en función de la superficie y podemos calcular nuevos ratios con los originales.

```{r read_data}
df <- read_parquet("../data/info_general_barrio.parquet")
df[is.na(df)] <- 0
df$barrio <- as.factor(df$barrio)
df_superficie <- read.csv("../00_marc/dataTratada/barrios_indices.csv")
df_superficie[is.na(df_superficie)] <- 0
df_superficie$barrio <- as.factor(df_superficie$barrio)

a <- cbind(barrio = df$barrio,geojson_sf(df$geo_shape))

df_superficie <- merge(a, df_superficie, by = "barrio", all.y=TRUE)
```





## Ratios de comparación

### Número de paradas de metro, bus y valenbisi por $m^2$

Para este podemos utilizar directamente el dataframe con los datos divididos por la superficie.



```{r}
ratio_sup <- df_superficie %>% select(barrio, paradas_metro, paradas_emt, estaciones_valenbisi)


ratio_sup <- ratio_sup %>% arrange(desc(paradas_emt))
ratio_sup[1:10,] %>%
  ggplot(aes(x = reorder(barrio, -paradas_emt), y = paradas_emt)) +
  geom_bar(stat = "identity", fill = "mediumaquamarine")+  
  labs(x = "Nombres", y = "Valores", title = "Gráfico de Barras")+
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 60, hjust = 1))
``` 



```{r}
colors_emt <- colorNumeric(palette = colorRamp(c("#f0f8ff", "#35434c"), interpolate = "spline"), domain = df_superficie$paradas_emt)

m_emt <- leaflet() %>%
  addTiles(urlTemplate = "") %>%
  addPolygons(data = df_superficie, fillColor = ~colors_emt(paradas_emt),
              fillOpacity = 1, weight = 0.5, color = "black",
              popup = ~paste(barrio, "<br>", "Paradas de bus por m2: ", round(paradas_emt,8))) %>%
  setView(lng = -0.377, lat = 39.465, zoom = 13)
m_emt

             
```





```{r}
colors_metro <- colorNumeric(palette = "YlOrRd", domain = df_superficie$paradas_metro)

m_metro <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = df_superficie, fillColor = ~colors_metro(paradas_metro),
              fillOpacity = 1, weight = 0.5, color = "black",
              popup = ~paste(barrio, "<br>", "Paradas de metro por m2: ", round(paradas_metro,8))) %>%
  setView(lng = -0.377, lat = 39.465, zoom = 12)
m_metro

             
```






```{r}
colors_valenbisi <- colorNumeric(palette = "YlOrRd", domain = df_superficie$estaciones_valenbisi)

m_valenbisi <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = df_superficie, fillColor = ~colors_valenbisi(estaciones_valenbisi),
              fillOpacity = 1, weight = 0.5, color = "black",
              popup = ~paste(barrio, "<br>", "Estaciones de valenbisi por m2: ", round(estaciones_valenbisi, 8))) %>%
  setView(lng = -0.377, lat = 39.465, zoom = 12)

m_valenbisi

             
```












```{r}
colors_eco <- colorNumeric(palette = "YlOrRd", domain = df_superficie$eco_friendly)

m_eco <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = df_superficie, fillColor = ~colors_eco(eco_friendly),
              fillOpacity = 1, weight = 0.5, color = "black",
              popup = ~paste(barrio, "<br>", "Índice ecológico : ", round(eco_friendly, 3))) %>%
  setView(lng = -0.377, lat = 39.465, zoom = 12)
m_eco

             
```









```{r}
'saveRDS(m_emt, file = "../00_marc/mapas/ratio_emt.rds")
saveRDS(m_metro, file = "../00_marc/mapas/ratio_metro.rds")
saveRDS(m_valenbisi, file = "../00_marc/mapas/ratio_valenbisi.rds")
saveRDS(m_eco, file = "../00_marc/mapas/ratio_eco.rds")'
```






```{r}
library(igraph)
library(mapview)
library(webshot)
establecer_barrio<- function(punto, info_poligonos) {
  # Recibe un objeto de tipo punto y un dataframe con la información de los polígonos y el barrio
  b <- unlist(st_within(punto, info_poligonos$geometry))
  if (length(b) == 0) {
    return(NA)
  } else {
    return(info_poligonos$barrio[b])
  }
}

carac_metro <- read_parquet("../data/caracteristicas_metro.parquet")
poligonos_barrios <- read_parquet("../data/info_general_barrio.parquet")
poligonos_barrios[is.na(poligonos_barrios)] <- 0
# En la siguiente función, el parámetro crs indica el sistema de referencia de coordenadas
estaciones <- st_as_sf(carac_metro, coords = c("stop_lon", "stop_lat"), crs = 4326)
poligonos_barrios <- cbind(poligonos_barrios, geojson_sf(poligonos_barrios$geo_shape))


estaciones$barrio <- sapply(1:nrow(estaciones), function(i) {
  establecer_barrio(estaciones[i,], poligonos_barrios)
})

carac_metro <- merge(carac_metro, estaciones[,c("stop_id", "barrio")], by = "stop_id", all.x = TRUE)
write.csv2(carac_metro, "./carac_metro_barrio.csv", row.names = FALSE)

barrios <- read.csv("../00_marc/dataTratada/barrios_indices.csv")
barrios[is.na(barrios)] <- 0
barrios_total <- read.csv("../00_marc/dataTratada/barrios_final.csv")
carac_metro_barrio <- data.frame()

carac_metro_barrio <- barrios %>% select(-paradas_metro, -paradas_emt, -estaciones_valenbisi) %>%
  merge(carac_metro, by = "barrio", all.y = TRUE)
b <- poligonos_barrios %>% select(-paradas_metro, -geo_shape, -precio_alquiler,
                                                   -geometry, -distrito)
carac_metro_barrio <- b %>%
  merge(carac_metro_barrio, by = "barrio", all.y = TRUE)
carac_metro_barrio <- barrios_total %>% select(barrio, RENTA_BRUTA, SALARIO, Precio_alquiler.m2, 
                                               Precio_venta.m2) %>%
  merge(carac_metro_barrio, by = "barrio", all.y = TRUE)

carac_metro_barrio <- carac_metro_barrio[!is.na(carac_metro_barrio$barrio) |
                                           carac_metro_barrio$stop_id %in% c("55","56"),]

load("graph_metro_valencia.RData")

g_valencia <- induced_subgraph(g, V(g)$name %in% carac_metro_barrio$stop_id)


aux <- data.frame(apply(carac_metro[,c("pagerank", "closeness", "betweenness", "eigenvector")],
                        2, function(x) x/max(x)))

carac_metro <- carac_metro %>%
  select(-c("pagerank", "closeness", "betweenness", "eigenvector")) %>%
  cbind(aux)

mapa <- readRDS("../00_marc/mapas/ratio_emt.RDS")

plot_graph <- function(m, dataset,color, tamanyo){
  
  library(leaflet)
    
  colors <- colorNumeric(palette = "YlGnBu", domain = color)
  
  b <- st_as_sf(dataset, crs = 4326)
  
  
    plot_isochron <- function(subgrafo) {
    
    edge_list <- as_edgelist(subgrafo)
    
    #m = leaflet() %>% addTiles() # urlTemplate = ""
    
      for (i in 1:nrow(edge_list)) {
        edge <- edge_list[i,]
        head_edge <- V(subgrafo)[edge[1]]
        tail_edge <- V(subgrafo)[edge[2]]
        
        m <- m %>%
          addPolylines(lng = c(head_edge$lon, tail_edge$lon), lat = c(head_edge$lat, tail_edge$lat),
                       color = "#35434c", weight = 2, opacity = 0.9)
      }
      
      # add nodes to map
      #m <- m %>% addCircleMarkers(lng = V(subgrafo)$lon, lat = V(subgrafo)$lat, radius = 5, color = "red")
      #m <- m %>% addCircleMarkers(lng = start_node$x, lat = start_node$y, radius = 5, color = "yellow")
      return(m)
    }
  
  
  mapa <- plot_isochron(g)
  
  mapa <- mapa %>%
    addCircleMarkers(data = b, color = ~colors(color), radius = ~(tamanyo^1.3)+3, fillOpacity = 1,
                     popup = ~paste(stop_name))
  
  
  mapa
}



m <- plot_graph(m_emt, carac_metro, color = carac_metro$closeness, tamanyo = carac_metro$n_lines)
mapshot(m, file = "emt_closeness_n_lines.png")
m
```

