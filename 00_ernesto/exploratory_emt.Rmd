---
title: "Análisis de bus emt Valencia"
author: "Ernesto Martínez"
output: 
  html_document:
    toc: true
    number_sections: false
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r include = FALSE}
.lib<- c("dplyr", "leaflet", "ggplot2", "tidytransit", "sf", "lubridate")

.inst <- .lib %in% installed.packages()
if (length(.lib[!.inst])>0) install.packages(.lib[!.inst])
lapply(.lib, require, character.only=TRUE)
```

## Lectura de datos y exploración inicial

```{r}
gtfs <- read_gtfs("../data/gtfs_data/transit_emt_valencia.zip")
print(names(gtfs))
```

```{r}
print(head(gtfs$.$dates_services))
```


```{r}
summary(gtfs)
```

```{r}
head(gtfs$shapes)
```

```{r}
str(gtfs$fare_attributes)
```

```{r}
str(gtfs$fare_rules)
```

```{r}
str(gtfs$transfers)
```

```{r}
head(gtfs$frequencies)
```

```{r}
gtfs$stopsData$location_type <- as.factor(gtfs$stopsData$location_type)
names(gtfs$stopsData)
```

```{r}
names(gtfs$stops)
```

```{r}
gtfs$stops
```


```{r}
gtfs$trips
```

Las los viajes de bus se diferencian en ida y vuelta con una V o una I al final del shape_id y en el trip_id. Vamos a crear una columna nueva para saber si es ida o vuelta.

```{r}
gtfs$trips$is_round_trip <- grepl("V$", gtfs$trips$shape_id)
head(gtfs$trips$is_round_trip)
```


```{r}
gtfs$routes
```

## Análisis del calendario

Existe una variable llamada service_id, que indica el tipo de servicio que se ofrece ese día. También sirve para saber qué trenes (rutas) están en servicio ese día.

En el dataframe de calendario tenemos qué día de la semana corresponde a cada servicio.

```{r}
gtfs$calendar$service_id <- as.factor(gtfs$calendar$service_id)
gtfs$trips$service_id <- as.factor(gtfs$trips$service_id)

gtfs$calendar
```

Se diferencian dos tipos de horarios según las fechas de inicio y fin de servicio. El servicio es distinto para verano y para el resto del año. Coinciden en que comienzan por "V".

Podemos ver que hay 3 tipos de servicios principales: LAB, SAB y FES. LAB es el servicio de lunes a viernes, SAB es el servicio de sábados y FES es el servicio de domingos y festivos. En verano son iguales pero con una "V" delante.

Además, también hay algunos servicios alternativos cuando no es verano (NLAB, NFS, L38-755	L38-810), que se ofrecen en días concretos.

Para saber qué servicio se ofrece en un día específico teniendo en cuenta las posibles exceptiones en el servicio necesitamos otro dataframe (`calendar_dates`) que nos dé información sobre el servicio de cada día.

```{r}
summary(gtfs$calendar_dates)
```

```{r}
head(gtfs$calendar_dates)
```

```{r}
gtfs$calendar_dates$exception_type <- as.factor(gtfs$calendar_dates$exception_type)
gtfs$calendar_dates <- gtfs$calendar_dates %>% 
  mutate(weekday = wday(gtfs$calendar_dates$date, week_start = 1)) %>%
  arrange(date)
```

```{r}
gtfs$calendar_dates
```

La variable exception_type es 1 o 2. Parece que está dando 2 a los servicios que se ofrecen esos días regularmente y 1 a los servicios que se ofrecen como excepción.

Tras crear una columna para ver qué día de la semana corresponde a cada fecha no se ha conseguido saber si hay alguna relación entre el tipo de servicio (diferente de LAB, SAB y FES) y el día de la semana.

Ahora vamos a calcular la frecuencia de cada servicio (service_id) en condicionada por el día de la semana con una tabla de contingencia.

```{r}
exception_2 <- gtfs$calendar_dates %>%
  filter(exception_type == 2)
contingency_table <- xtabs(~ service_id + weekday, data = exception_2)

contingency_table
```

Ahora se puede calcular la frecuencia relativa de cada servicio por día de la semana.

```{r}
# Calcula los totales por día de la semana
totals_by_weekday <- colSums(contingency_table)

# Divide cada elemento de la tabla de contingencia por su total de día de la semana correspondiente
relative_frequencies <- sweep(contingency_table, 2, totals_by_weekday, FUN="/")

relative_frequencies
```


```{r}
df_for_heatmap <- as.data.frame(as.table(relative_frequencies))
names(df_for_heatmap) <- c("weekday", "service_id", "frequency")

ggplot(df_for_heatmap, aes(x = service_id, y = weekday, fill = frequency)) +
  geom_tile() + 
  geom_text(aes(label = round(frequency, 2)), color = "black", size = 3) + 
  scale_fill_gradient(low = "white", high = "mediumaquamarine", name = "Frecuencia\nRelativa") +
  labs(title = "Frecuencias Relativas de Service_ID por Columna",
       x = "Día de la Semana", y = "ID de Servicio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

En el mapa de calor parece haber una relación entre el tipo de servicio alternativo y el día de la semana en el que se ofrece. Por ejemplo, el servicio L38-755 se ofrece solo en fin de semana, mientras que el L38-755 se ofrece entre semana.


Podemos hacer lo mismo para el dataframe dates_services.

```{r}
gtfs$.$dates_services <- gtfs$.$dates_services %>%
  mutate(weekday = wday(date, week_start = 1)) %>%
  arrange(date)

gtfs$.$dates_services
```

En esta tabla aparecen varios servicios para cada día.

Veamos si las fechas son continuas, es decir, si aparecen todos los días

```{r}
gtfs$.$dates_services %>%
  summarise(min_date = min(date), max_date = max(date), n_dates = n_distinct(date), total_days = max_date - min_date + 1)
```

Parece ser que sí aparecen todos los días entre la fecha mínima y máxima del dataframe, luego tenemos los servicios para todos los días.

El problema ahora es que aparecen varios servicios por día. Veamos si hay alguna relación entre el tipo de servicio y el día de la semana.

```{r}
contingency_table <- xtabs(~ service_id + weekday, data = gtfs$.$dates_services)

contingency_table
```


```{r}
# Calcula los totales por día de la semana
totals_by_weekday <- colSums(contingency_table)

# Divide cada elemento de la tabla de contingencia por su total de día de la semana correspondiente
relative_frequencies <- sweep(contingency_table, 2, totals_by_weekday, FUN="/")

relative_frequencies
```


```{r}
df_for_heatmap <- as.data.frame(as.table(relative_frequencies))
names(df_for_heatmap) <- c("weekday", "service_id", "frequency")

ggplot(df_for_heatmap, aes(x = service_id, y = weekday, fill = frequency)) +
  geom_tile() + 
  geom_text(aes(label = round(frequency, 2)), color = "black", size = 3) + 
  scale_fill_gradient(low = "white", high = "mediumaquamarine", name = "Frecuencia\nRelativa") +
  labs(title = "Frecuencias Relativas de Service_ID por día de la semana",
       x = "Día de la Semana", y = "ID de Servicio") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

Aquí no estamos consiguiendo mucha más información de la que teníamos antes. Parece que los servicios L38-810 y L38-755 se ofrecen todos los días.


## Análisis de las rutas de bus

Podemos saber el número de buses por cada servicio.

```{r}
gtfs$trips %>%
  group_by(service_id) %>%
  summarise(frequency = n()) %>%
  arrange(desc(frequency))
```

El número de buses de los días laborales es menor que el de los sábados y este menor que el de los domingos y festivos. LAB < SAB < FES

Resulta que en el dataset de trips no aparecen los servicios alternativos, como los de verano, a excepción del servicio L38.

Veamos qué rutas están contenidas en el servicio L38.

```{r}
trips_L38 <- gtfs$trips %>%
  filter(service_id == "L38-810" | service_id == "L38-755")

unique(trips_L38$route_id)
```

Solo aparece una ruta en este servicio, de id = 38. Se corresponde con la línea 98 de bus. Es posible que esté en un servicio distinto porque no cambia a lo largo de la semana ni en los festivos.

Ahora vamos a ver cuántas rutas tiene cada servicio

```{r}
gtfs$trips %>%
  group_by(service_id) %>%
  summarise(n_routes = n_distinct(route_id)) %>%
  arrange(desc(n_routes))
```

De aquí en adelante usaremos el servicio LAB + L38-755, que es el que se usa entre semana.

```{r}
trips <- gtfs$trips %>%
  filter(service_id == "LAB" | service_id == "L38-755")
```

Cuáles son las rutas más frecuentes:

```{r}
# get the frequency for routes
trips %>%
  group_by(route_id) %>%
  summarise(frequency = n()) %>%
  arrange(desc(frequency))

```

Parece ser que para algunas rutas aparecen muy pocos trips, mientras que hay muchos más en otras. Esto resulta raro, ya que no tiene sentido que solo haya 2 buses de una ruta mientras que hay 146 de otra.

Estas rutas están identificadas por un id, que corresponde al recorrido exacto que hace el bus. Sin embargo, este id no nos da información sobre el nombre de línea. Observemos ahora cuáles son las líneas más frecuentes.

Será necesario unir los datasets de rutas y líneas para poder obtener el número de línea.

```{r}

# merge the routes with the trips
trips_routes <- trips %>%
  inner_join(gtfs$routes, by = "route_id")

trips_routes %>%
  group_by(route_long_name) %>%
  summarise(frequency = n()) %>%
  arrange(desc(frequency)) %>%
  print(n = 10)
```

Ahora vamos a ver cuáles son todas las rutas que hay y cuántos servicios las incluyen hay para cada una.

```{r}
unique_routes <- trips_routes %>%
  distinct(service_id, route_short_name, route_long_name) %>%
  arrange(route_short_name)
unique_routes
```

Como hemos comprobado antes, el servicio L38-755 solo tiene una ruta, la 98.

Para conseguir cuántas paradas hay por cada ruta y cuáles son:

```{r}
trips_stops_details <- trips %>%
  left_join(gtfs$routes, by = "route_id") %>%
  left_join(gtfs$stop_times, by = "trip_id") %>%
  left_join(gtfs$stops, by = "stop_id")


stops_by_route <- trips_stops_details %>%
  select(route_id, route_long_name, trip_id, stop_id, stop_sequence, stop_name, stop_lat, stop_lon, is_round_trip) %>%
  arrange(route_long_name, trip_id, stop_sequence)
```

Ahora tenemos un dataframe con todas las paradas de todas las rutas, ordenadas por la secuencia de paradas. Para esto también hay que ver si el viaje es de ida o de vuelta con la columna que se ha creado al principio.

```{r}
unique_stops_by_route <- stops_by_route %>%
  distinct(route_id, route_long_name, stop_id, .keep_all = TRUE) %>%
  arrange(route_id, stop_sequence)

head(unique_stops_by_route)
```

Podemos ver las paradas de cualquier ruta sabiendo su id. Por ejemplo, para la ruta 10 (línea BENIMACLET - SANT MARCELÍ):

```{r}
stops_for_a_specific_route <- unique_stops_by_route %>%
  filter(route_id == 10 & is_round_trip == FALSE) # viaje de ida
stops_for_a_specific_route %>%
  select(stop_id, stop_name, stop_sequence)
```

También se puede saber el número de paradas que tiene cada ruta:

```{r}  
stops_by_route <- unique_stops_by_route %>%
  group_by(route_id, route_long_name, is_round_trip) %>%
  summarise(n_stops = n(), .groups = "drop") %>%
  arrange(desc(n_stops))

stops_by_route
```

## Análisis según el horario

Se van a dividir los horarios según la franja horaria del día, de forma que se puede ver si hay diferencias en el servicio de bus y tranvía en distintos momentos del día.

```{r}
stop_times <- gtfs$stop_times %>%
  inner_join(gtfs$stops, by = "stop_id") %>%
  inner_join(trips, by = "trip_id") # aquí ya se incluye el filtro anterior del service_id
```

```{r}
stop_times %>%
  arrange(arrival_time)
```


Vamos a ver el número de buses por hora.

```{r}
buses_por_hora <- stop_times %>%
  group_by(hora = hour(arrival_time)) %>%
  summarise(n_bus = n()) %>%
  arrange(hora)

buses_por_hora
```


En un gráfico de barras se puede ver mejor la distribución de buses por hora.

```{r}
ggplot(buses_por_hora, aes(x = hora, y = n_bus)) +
  geom_bar(stat = "identity", fill="mediumaquamarine") +
  labs(title = "Número de buses por hora",
       x = "Hora",
       y = "Número de buses")+
  theme_minimal()
```

Se puede ver cómo la franja principal de actividad es entre las 7 de la mañana y las 10 de la noche. Sorprende ver que hay más buses a las 12 de la noche que en cualquier otra hora del día.

### Análisis por franjas horarias

```{r}
stop_times <- stop_times %>%
  mutate(time_of_day = case_when(
    hour(arrival_time) >= 6 & hour(arrival_time) < 9 ~ "Morning",
    hour(arrival_time) >= 9 & hour(arrival_time) < 12 ~ "Mid morning",
    hour(arrival_time) >= 12 & hour(arrival_time) < 15 ~ "Midday",
    hour(arrival_time) >= 15 & hour(arrival_time) < 18 ~ "Evening",
    hour(arrival_time) >= 18 & hour(arrival_time) < 21 ~ "Afternoon",
    hour(arrival_time) >= 21 | hour(arrival_time) < 6 ~ "Night",
    TRUE ~ "Otro"
  ))


head(stop_times)
```

```{r}
tail(stop_times)
```



```{r}
stop_times %>%
  filter(time_of_day == "Night") %>%
  arrange(desc(arrival_time)) %>%
  head()
```
Hay algunos buses que pasan a las 26 horas, lo que puede dar lugar a confusión. Esto ocurre para que sea más fácil ordenar los buses por hora. Es decir, si un bus pasa a las 26:30 horas, se considera que pasa a las 2:30 horas del día siguiente.

Al filtrar stop_times por una parada en concreto, se puede ver el horario del bus de esa parada.

```{r}
# 89 es el id de la parada Blasco Ibáñez - Hondures
times_honduras <- stop_times %>%
  filter(stop_id == "126") %>%
  arrange(arrival_time)

head(times_honduras)
```

También se puede ver el número de buses por franja horaria tanto en total como en una sola parada.

```{r}
stop_times %>%
  group_by(time_of_day) %>%
  summarise(n_buses = n())
```

Es interesante ver que en la franja de _Morning_ hay menos buses que en el resto de franjas del día. Esto se debe a que están incluidas las 6 y las 7 a.m. y a esa hora no hay mucho servicio de bus.

Ahora se va a ver el número de buses por franja horaria en la parada de Honduras.

```{r}
times_honduras %>%
  group_by(time_of_day) %>%
  summarise(n_buses = n())
```

Ocurre un caso extraño, ya que solo hay 2 buses que pasan por esta parada. Esto puede deberse a que los buses no tienen un horario fijo, sino que se da una frecuencia aproximada de paso.

## Caracterización de las líneas de bus

Para cada service_id, para cada estación pordemos conocer las siguientes características:

- Nº de buses / hora
- Nº de buses / día
- Nº de buses totales
- Nº de buses / hora por línea
- Nº de buses / día por línea

También se puede crear un grafo con las estaciones y las líneas de bus, de forma que podamos extraer más características como la intermediación de una estación, su grado (número de estaciones con las que se conecta directamente), etc.

### Nº de buses

Es necesario unir las tablas de rutas, trips, stop_times y stops para esta tarea y las siguientes:

```{r}
trips_stops_details <- trips %>%
  inner_join(gtfs$routes, by = "route_id") %>%
  inner_join(gtfs$stop_times, by = "trip_id") %>%
  inner_join(gtfs$stops, by = "stop_id")

head(trips_stops_details)
```

```{r}
nrow(trips_stops_details)
```

El número de buses totales cada día es de 29.864


### Número de buses por hora por estación.


```{r}
buses_por_hora <- trips_stops_details %>%
  group_by(stop_id, stop_name, hour = hour(arrival_time)) %>%
  summarise(buses = n())

buses_por_hora
```

Quiero trasponer las columnas hour y buses para tener una columna por cada hora, de forma que sea más fácil ver la tabla para cada estación.

```{r}
library(tidyr)
buses_por_hora_t <- buses_por_hora %>%
  pivot_wider(names_from = hour, values_from = buses, values_fill = 0)

head(buses_por_hora_t)
```

El número de buses por hora por estación incluye tanto los de entrada como los de salida.

### Número de buses por día por estación

Es tan fácil como sumar los buses por hora del dataframe creado antes.

```{r}
buses_por_dia <- buses_por_hora %>%
  group_by(stop_id, stop_name) %>%
  summarise(buses = sum(buses), .groups = "drop")
  

head(buses_por_dia)
```

Para ver la distribución de buses por estación al día, se puede hacer un histograma que la muestre.

```{r}
ggplot(buses_por_dia, aes(x = buses)) +
  geom_histogram(fill = "mediumaquamarine", color = "black", bins=10) +
  labs(title = "Distribución de buses por día por estación",
       x = "Número de buses",
       y = "Número de estaciones") +
  theme_minimal()
```

```{r}
buses_por_dia %>%
  arrange(desc(buses)) %>%
  head(10)
```



### Número de líneas que pasan por cada estación, con una columna que contiene una lista con las líneas y otra con el número de líneas


```{r}
lines_per_station <- trips_stops_details %>%
  group_by(stop_id, stop_name, is_round_trip) %>%
  summarise(lines = list(unique(route_short_name)), n_lines = length(unique(route_short_name)))

lines_per_station
```

Ahora se buscará una tabla con los buses por hora de cada línea y cada estación.
Se agrupará por `route_short_name`, `stop_id` y `hour` y se sumarán los buses.

```{r}
buses_por_hora_linea <- trips_stops_details %>%
  group_by(route_short_name, stop_id, stop_name, hour = hour(arrival_time)) %>%
  summarise(buses = n())

buses_por_hora_linea
```

Se traspondrá la tabla para tener una columna por cada hora

```{r}
buses_por_hora_linea_t <- buses_por_hora_linea %>%
  pivot_wider(names_from = hour, values_from = buses, values_fill = 0)

buses_por_hora_linea_t
```

También se puede saber el número de buses por día por línea y estación

```{r}
buses_por_dia_linea <- buses_por_hora_linea %>%
  group_by(route_short_name, stop_id, stop_name) %>%
  summarise(buses = sum(buses))

head(buses_por_dia_linea)
```


## Grafo de estaciones y líneas de bus



Se creará un grafo con las estaciones y las líneas de bus.

Primero se creará un dataframe con las estaciones y las líneas de bus que pasan por cada estación

### Preparación de los datos

```{r}
lines_per_station <- trips_stops_details %>%
  group_by(stop_id, stop_name) %>%
  summarise(lines = list(unique(route_short_name)), n_lines = length(unique(route_short_name)))

lines_per_station
```

Ahora se pueden ver las líneas que pasan por cada estación.

```{r}
head(lines_per_station$lines)
```

Para crear el grafo, se necesita una lista de nodos y de aristas. La lista de nodos será la lista de estaciones y la lista de aristas se obtendrá de las líneas de bus, uniendo dos a dos las estaciones que pertenecen a la misma línea y que están en la misma secuencia de paradas. El peso de las aristas será el tiempo que se tarda en llegar desde una estación a otra.

Primero se creará la lista de nodos

```{r}
nodes <- lines_per_station %>%
  select(stop_id, stop_name) %>%
  rename(id = stop_id, name = stop_name)

nodes
```

Veamos ahora qué estaciones pertenecen a cada línea. Primero se unirán las tablas de paradas y de rutas

```{r}
stops_routes <- trips_stops_details %>%
  select(stop_id, stop_name, route_id, route_long_name, route_short_name, is_round_trip) %>%
  distinct()

stops_routes
```

Ahora quiero una lista de todas las paradas que contiene cada ruta, ordenadas por la secuencia de paradas

```{r}
stops_routes_ordered <- stops_routes %>%
  group_by(route_id, route_short_name, route_long_name, is_round_trip) %>%
  
  arrange(route_id, stop_id) %>%
  summarise(stops = list(stop_id), n_stops = n())

stops_routes_ordered
```

Por ejemplo, podemos ver qué id corresponden a las paradas de la línea 1 - Castelló - Empalme

```{r}
stops_routes_ordered$stops[[1]]
```

Para no realizar trabajo de más, al haber muchas rutas que contienen las mismas paradas, se puede comprobar si hay rutas que son subconjuntos de otras.

```{r}
is_subset <- rep(FALSE, nrow(stops_routes_ordered))

for (i in 1:nrow(stops_routes_ordered)) {
  for (j in 1:nrow(stops_routes_ordered)) {
    if (i != j) {
      r1 <- stops_routes_ordered$stops[[i]]
      r2 <- stops_routes_ordered$stops[[j]]
      if (all(r1 %in% r2) && length(r1) < length(r2)) {
        is_subset[i] <- TRUE
      }
    }
  }
}

stops_routes_ordered$is_subset <- is_subset
```

Conseguidas las rutas que están contenidas en otras, nos quedaremos con las rutas __maximales__, es decir, las que no están contenidas en otras.

```{r}
routes_non_subset <- stops_routes_ordered %>%
  filter(is_subset == FALSE)

head(routes_non_subset)
```

```{r}
print(nrow(routes_non_subset))
```

Hay 90 líneas _maximales_ contando ida y vuelta como diferentes.


Es el momento de obtener la estación de salida de cada ruta y la estación de fin.
Se crearán dos columnas en la tabla stops_routes_ordered con la estación de salida y la estación de fin, que se obtienen a partir de dividir la columna `route_long_name` con " - ".


```{r}
routes_non_subset <- routes_non_subset %>%
  mutate(start_station = sapply(strsplit(route_long_name, " - "), function(x) x[1]),
         end_station = sapply(strsplit(route_long_name, " - "), function(x) x[2]))

head(routes_non_subset)
```

Ahora se van a conseguir un trip para cada ruta maximal, de forma que se pueda obtener la secuencia de paradas de cada ruta.

```{r}
trips_routes_non_subset <- trips %>%
  inner_join(routes_non_subset, by = c("route_id", "is_round_trip")) %>%
  select(route_id, service_id, trip_id, route_short_name, route_long_name, start_station, end_station, stops, n_stops, is_round_trip)

# Dejar solo una fila para cada route_id
trips_routes_non_subset <- trips_routes_non_subset %>%
  distinct(route_id, .keep_all = TRUE)

head(trips_routes_non_subset)
```

La forma de conseguir el horario de un trip es la siguiente:

```{r}
trip_ejemplo <- trips_routes_non_subset$trip_id[1]

trip_ejemplo_completo <- gtfs$stop_times %>%
  filter(trip_id == trip_ejemplo) %>%
  inner_join(gtfs$stops, by = "stop_id") %>%
  select(stop_id, stop_name, arrival_time, departure_time, stop_sequence) %>%
  arrange(stop_sequence)

trip_ejemplo_completo
```

Ahora se van crear pares de paradas consecutivas en cada trip, con sus correspondientes horas de llegada. Además, se incluirá la duración del viaje restando la hora de llegada de la segunda parada con la hora de llegada de la primera parada.

```{r}
pares_paradas <- trip_ejemplo_completo %>%
  select(stop_id, stop_name, arrival_time) %>%
  slice(1:(nrow(.) - 1)) %>%
  rename(stop_id_1 = stop_id, stop_name_1 = stop_name, arrival_time_1 = arrival_time) %>%
  bind_cols(trip_ejemplo_completo %>%
              select(stop_id, stop_name, arrival_time) %>%
              slice(2:nrow(.)) %>%
              rename(stop_id_2 = stop_id, stop_name_2 = stop_name, arrival_time_2 = arrival_time))

# crear una columna con la duración del trayecto
pares_paradas <- pares_paradas %>%
  mutate(duration = as.numeric(difftime(arrival_time_2, arrival_time_1, units = "mins")))

pares_paradas
```

Ahora hay que realizar este proceso para todos los trips que se han conseguido antes.

```{r}
all_stops_pairs <- list()

for (i in 1:nrow(trips_routes_non_subset)) {
  trip_i <- trips_routes_non_subset$trip_id[i]
  
  trip_completo <- gtfs$stop_times %>%
    filter(trip_id == trip_i) %>%
    inner_join(gtfs$stops, by = "stop_id") %>%
    select(stop_id, stop_name, arrival_time, departure_time, stop_sequence) %>%
    arrange(stop_sequence)
  
  pares_paradas <- trip_completo %>%
    select(stop_id, stop_name, arrival_time) %>%
    slice(1:(nrow(.) - 1)) %>%
    rename(stop_id_1 = stop_id, stop_name_1 = stop_name, arrival_time_1 = arrival_time) %>%
    bind_cols(trip_completo %>%
                select(stop_id, stop_name, arrival_time) %>%
                slice(2:nrow(.)) %>%
                rename(stop_id_2 = stop_id, stop_name_2 = stop_name, arrival_time_2 = arrival_time))
  
  # crear una columna con la duración del trayecto
  pares_paradas <- pares_paradas %>%
    mutate(duration = as.numeric(difftime(arrival_time_2, arrival_time_1, units = "mins")))
  
  all_stops_pairs[[i]] <- pares_paradas
}

complete_trips <- bind_rows(all_stops_pairs)
tail(complete_trips)
```

En este momento tenemos muchas filas con los mismos pares de paradas, ya que pese a haber eliminado las rutas que estaban contenidas en otras, hay rutas que comparten paradas. Por lo tanto, se eliminarán las filas duplicadas.

```{r}
# delete duplicated rows
complete_trips <- complete_trips %>%
  distinct(stop_id_1, stop_id_2, .keep_all = TRUE)

```

A los vértices se les puede añadir atributos con su latitud y longitud. Para eso hay que unir la tabla complete_trips con gtfs$stops.

```{r}
complete_trips <- complete_trips %>%
  inner_join(gtfs$stops, by = c("stop_id_1" = "stop_id")) %>%
  select(-stop_name) %>%
  rename(lat_1 = stop_lat, lon_1 = stop_lon) %>%
  inner_join(gtfs$stops, by = c("stop_id_2" = "stop_id")) %>%
  select(-stop_name) %>%
  rename(lat_2 = stop_lat, lon_2 = stop_lon)

complete_trips
```

Con el dataframe conseguido tenemos la información suficiente para puede crear el grafo con las estaciones y las líneas de bus.

```{r}
node_pairs <- complete_trips %>%
  select(stop_id_1, stop_id_2) 
```

Para no tener nodos duplicados, se eliminará una de las direcciones en los pares de nodos.

```{r}
# drop duplicates from complete_trips
distinct_nodes <- complete_trips %>%
  distinct(stop_id_1, stop_id_2, .keep_all = TRUE)

nrow(distinct_nodes)
```

### Construcción del grafo

Se usará la librería igraph para construir un grafo que contiene la red de bus.

```{r}
library(igraph)

g <- graph_from_data_frame(node_pairs, directed = TRUE)

V(g)$stop_name <- distinct_nodes$stop_name_1
E(g)$weight <- complete_trips$duration
```

Hay que añadir un trasbordo entre las paradas Alacant y Xàtiva (bidireccional) de 5 minutos y uno igual para las paradas de Alacant y Bailén de 3 minutos, ya que en la realidad hay un trasbordo entre ellas y en el dataset no aparece porque se hace andando.

```{r}
s1 = V(g)[stop_name == "Alacant"]
s2 = V(g)[stop_name == "Xàtiva"]
s3 = V(g)[stop_name == "Bailén"]


t1 = edge(s1, s2)
t2 = edge(s1, s3)
t3 = edge(s2, s1)
t4 = edge(s3, s1)

# añadir todos los trasbordos al grafo
g = add_edges(g, c(t1, t2, t3, t4))

# poner el peso a cada trasbordro
E(g)$weight[tail(seq_along(E(g)$weight), 4)] <- c(5, 3, 5, 3)
```

Ahora se añadirán los atributos de latitud y longitud a los nodos, así como la zona en la que se encuentra en la parada.

```{r}
V(g)$lat <- distinct_nodes$lat_1
V(g)$lon <- distinct_nodes$lon_1
V(g)$zone <- distinct_nodes$zone_id.x
```



### Estudio de las propiedades de grafo

Ahora que tenemos los datos en forma de grafo, podemos analizar métricas de la red de bus que antes eran imposibles o más difíciles de conseguir.

Distribución de grado (entrada + salida)

```{r}
degree_distribution <- degree(g)

hist(degree_distribution, breaks = 20, main = "Degree Distribution", xlab = "Degree")
```

```{r}
print(V(g)[which.max(degree_distribution)]$stop_name)
print(V(g)[neighbors(g, which.max(degree_distribution))]$stop_name)
```

Ahora se puede conseguir el camino más corto de una estación cualquiera hasta otra.

```{r}
# shortet path from benimaclet to sant isidre
s1 <- V(g)[stop_name == "Sant Isidre"]
s2 <- V(g)[stop_name == "Àngel Guimerà"]

shortest_path <- shortest_paths(g, from = s2, to = s1)

# get the path
shortest_path$vpath[[1]]$stop_name
```

Falta incluir qué líneas de bus pasan por cada estación. Se usará el df lines_per_station que ya se ha creado antes.

```{r}
# sort the same as the graph
distinct_nodes <- distinct_nodes %>%
  inner_join(lines_per_station, by = c("stop_id_1" = "stop_id")) %>%
  select(-stop_name) %>%
  rename(stop_name = stop_name_1)

distinct_nodes
```

```{r}
V(g)$lines <- distinct_nodes$lines

```

Ahora solo queda poner en qué líneas está cada par de nodos (ruta entre uno y otro). Para esto, se usará la intersección entre las líneas que están en un nodo y las del siguiente


```{r}
E(g)$lines <- NA


for (i in 1:length(E(g))) {
  edge <- E(g)[i]
  from <- head_of(g, edge)
  to <- tail_of(g, edge)
  
  lines_from <- V(g)[from]$lines[[1]]
  lines_to <- V(g)[to]$lines[[1]]
  
  E(g)$lines[i] <- list(intersect(lines_from, lines_to))
}
```

Ya que hemos conseguido incluir las líneas en el grafo, veamos el recorrido de una, por ejemplo, la 4.

```{r}
is_line_4 <- rep(NA, length(V(g))) 

for (i in 1:length(V(g))) {
  is_line_4[i] <- "4" %in% V(g)$lines[[i]]
}
```


```{r}
line_4_graph <- induced_subgraph(g, is_line_4)

# plot the graph
plot(line_4_graph, vertex.label = V(line_4_graph)$stop_name, vertex.size = 10, edge.width = 1, edge.arrow.size = 0.5, layout = layout_nicely, main = "Line 4")
```

Vamos a comprobar que el grafo tiene una sola componente conexa.

```{r}
# componentes conexas
g_undirected <- as.undirected(g)
components(g_undirected)$no
```

Tiene solo una componente conexa porque se han añadido los trasbordos entre las estaciones de Alacant y las más cercanas, ya que no hay bus entre ellas pero en la realidad existe un trasbordo entre ellas.


Ahora es un buen momento para crear un dataset que incluya cada parada de bus y métricas conseguidas desde el grafo, teniendo en cuenta que cada parada es un nodo.

Las medidas a conseguir son:
- Grado de entrada
- Grado de salida
- Betweenness (intermediación)

```{r}
# grado de entrada
V(g)$in_degree <- degree(g, mode = "in")

# grado de salida
V(g)$out_degree <- degree(g, mode = "out")

# betweeness
V(g)$betweenness <- betweenness(g)

# closeness
V(g)$closeness <- closeness(g)


```






































































